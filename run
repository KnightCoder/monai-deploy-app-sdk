#!/bin/bash
#
# Copyright 2021 MONAI Consortium
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#     http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

init_globals() {
    if [ "$0" != "/bin/bash" ]; then
        SCRIPT_DIR=$(dirname "$(readlink -f "$0")")
        export RUN_SCRIPT_FILE="$(readlink -f "$0")"
    else
        export RUN_SCRIPT_FILE="$(readlink -f "${BASH_SOURCE[0]}")"
    fi

    export TOP=$(git rev-parse --show-toplevel || $(dirname "${RUN_SCRIPT_FILE}"))
    MONAI_PY_EXE=${MONAI_PY_EXE:-"python3"}
    export MONAI_PY_EXE
}

################################################################################
# Utility functions
################################################################################

#######################################
# Get list of available commands from a given input file.
#
# Available commands and command summary are extracted by checking a pattern
# "_desc() { c_echo '".
# Section title is extracted by checking a pattern "# Section: ".
# This command is used for listing available commands in CLI.
#
# e.g.)
#   "# Section: String/IO functions"
#     => "# String/IO functions"
#   "to_lower_desc() { c_echo 'Convert to lower case"
#     => "to_lower ----------------- Convert to lower case"
#
# Arguments:
#   $1 - input file that defines commands
# Returns:
#   Print list of available commands from $1
#######################################
get_list_of_available_commands() {
    local mode="color"
    if [ "${1:-}" = "color" ]; then
        mode="color"
        shift
    elif [ "${1:-}" = "nocolor" ]; then
        mode="nocolor"
        shift
    fi

    local file_name="$1"
    if [ ! -e "$1" ]; then
        echo "$1 doesn't exist!"
    fi

    local line_str='--------------------------------'
    local IFS= cmd_lines="$(IFS= cat "$1" | grep -E -e "^(([[:alpha:]_[:digit:]]+)_desc\(\)|# Section: )" | sed "s/_desc() *{ *c_echo '/ : /")"
    local line
    while IFS= read -r line; do
        local cmd=$(echo "$line" | cut -d":" -f1)
        local desc=$(echo "$line" | cut -d":" -f2-)
        if [ "$cmd" = "# Section" ]; then
            c_echo ${mode} B "${desc}"
        else
            # there is no substring operation in 'sh' so use 'cut'
            local dash_line="$(echo "${line_str}" | cut -c ${#cmd}-)"  #  = "${line_str:${#cmd}}"
             c_echo ${mode} Y "   ${cmd}" w " ${dash_line} ${desc}"
        fi
        # use <<EOF, not '<<<"$cmd_lines"' to be executable in sh
    done <<EOF
$cmd_lines
EOF
}

my_cat_prefix() {
    local IFS
    local prefix="$1"
    local line
    while IFS= read -r line; do
        echo "${prefix}${line}" # -e option doesn't work in 'sh' so disallow escaped characters
    done <&0
}

c_str() {
    local old_color=39
    local old_attr=0
    local color=39
    local attr=0
    local text=""
    local mode="color"
    if [ "${1:-}" = "color" ]; then
        mode="color"
        shift
    elif [ "${1:-}" = "nocolor" ]; then
        mode="nocolor"
        shift
    fi

    for i in "$@"; do
        case "$i" in
            r|R)
                color=31
                ;;
            g|G)
                color=32
                ;;
            y|Y)
                color=33
                ;;
            b|B)
                color=34
                ;;
            p|P)
                color=35
                ;;
            c|C)
                color=36
                ;;
            w|W)
                color=37
                ;;

            z|Z)
                color=0
                ;;
        esac
        case "$i" in
            l|L|R|G|Y|B|P|C|W)
                attr=1
                ;;
            n|N|r|g|y|b|p|c|w)
                attr=0
                ;;
            z|Z)
                attr=0
                ;;
            *)
                text="${text}$i"
        esac
        if [ "${mode}" = "color" ]; then
            if [ ${old_color} -ne ${color} ] || [ ${old_attr} -ne ${attr} ]; then
                text="${text}\033[${attr};${color}m"
                old_color=$color
                old_attr=$attr
            fi
        fi
    done
    /bin/echo -en "$text"
}

c_echo() {
    # Select color/nocolor based on the first argument
    local mode="color"
    if [ "${1:-}" = "color" ]; then
        mode="color"
        shift
    elif [ "${1:-}" = "nocolor" ]; then
        mode="nocolor"
        shift
    else
        if [ ! -t 1 ]; then
            mode="nocolor"
        fi
    fi

    local old_opt="$(shopt -op xtrace)" # save old xtrace option
    set +x # unset xtrace

    if [ "${mode}" = "color" ]; then
        local text="$(c_str color "$@")"
        /bin/echo -e "$text\033[0m"
    else
        local text="$(c_str nocolor "$@")"
        /bin/echo -e "$text"
    fi
    eval "${old_opt}" # restore old xtrace option
}

echo_err() {
    >&2 echo "$@"
}

c_echo_err() {
    >&2 c_echo "$@"
}

printf_err() {
    >&2 printf "$@"
}

get_item_ranges() {
    local indexes="$1"
    local list="$2"
    echo -n "$(echo "${list}" | xargs | cut -d " " -f "${indexes}")"
    return $?
}

get_unused_ports() {
    local num_of_ports=${1:-1}
    local start=${2:-49152}
    local end=${3:-61000}
    comm -23 \
    <(seq ${start} ${end} | sort) \
    <(ss -tan | awk '{print $4}' | while read line; do echo ${line##*\:}; done | grep '[0-9]\{1,5\}' | sort -u) \
    | shuf | tail -n ${num_of_ports} # use tail instead head to avoid broken pipe in VSCode terminal
}

newline() {
    echo
}

info() {
    c_echo W "$(date -u '+%Y-%m-%d %H:%M:%S') [INFO] " Z "$@"
}

error() {
    echo R "$(date -u '+%Y-%m-%d %H:%M:%S') [ERROR] " Z "$@"
}

fatal() {
    echo R "$(date -u '+%Y-%m-%d %H:%M:%S') [FATAL] " Z "$@"
    echo
    if [ -n "${SCRIPT_DIR}" ]; then
        exit 1
    fi
}

run_command() {
    local status=0
    local cmd="$*"

    c_echo B "$(date -u '+%Y-%m-%d %H:%M:%S') " W "\$ " G "${cmd}"

    [ "$(echo -n "$@")" = "" ] && return 1 # return 1 if there is no command available

    "$@"
    status=$?

    return $status
}

retry() {
    local retries=$1
    shift

    local count=0
    until run_command "$@"; do
        exit=$?
        wait=$((2 ** count))
        count=$((count + 1))
        if [ $count -lt $retries ]; then
            info "Retry $count/$retries. Exit code=$exit, Retrying in $wait seconds..."
            sleep $wait
        else
            fatal "Retry $count/$retries. Exit code=$exit, no more retries left."
            return 1
        fi
    done
    return 0
}

#==================================================================================
# Section: Inspect
#==================================================================================

get_package_info_desc() { c_echo 'Get package info from app(& model) path

Arguments:
  $1 - Application folder or file path
  $2 - Model path (optional)
'
}
get_package_info() {
    local app_path="${1:-}"
    local model_path="${2:-}"

    [ -z "${app_path}" ] && c_echo_err R "No application path specified." && return 1

    ${MONAI_PY_EXE} $TOP/monai/deploy/utils/importutil.py get_package_info ${app_path} ${model_path}
}

#==================================================================================
# Section: Build
#==================================================================================

install_python_dev_deps_() {
    if [ -n "${VIRTUAL_ENV}" ] || [ -n "${CONDA_PREFIX}" ]; then
        run_command ${MONAI_PY_EXE} -m pip install -q -U setuptools pip wheel
        run_command ${MONAI_PY_EXE} -m pip install -q -r ${TOP}/requirements-dev.txt
        run_command ${MONAI_PY_EXE} -m pip install -q -r ${TOP}/requirements-examples.txt

    else
        c_echo_err R "You must be in a virtual environment to install dependencies."
        if [ ! -e "$TOP/.venv/dev/bin/python3" ]; then
            c_echo_err W "Installing a virtual environment at " G "$TOP/.venv/dev" W " ..."
            run_command ${MONAI_PY_EXE} -m venv "$TOP/.venv/dev"
        fi

        c_echo_err W "Please activate the virtual environment at " G "$TOP/.venv/dev" W " and execute the setup command again."
        c_echo_err
        c_echo_err G "  source $TOP/.venv/dev/bin/activate"
        c_echo_err G "  $0 setup"
        exit 1
    fi

    # Create a symlink to the virtual environment.
    # This solves an issue with separate package folders for 'monai' and 'monai-app-sdk' like below:
    # - 'monai': installed with 'pip install monai'
    # - 'monai-app-sdk': installed with 'pip install -e .  # installed with development(edit) mode
    local monai_package_path=$(${MONAI_PY_EXE} $TOP/monai/deploy/utils/importutil.py dist_module_path monai)
    local sdk_package_path=$(${MONAI_PY_EXE} $TOP/monai/deploy/utils/importutil.py dist_module_path monai-app-sdk)
    local is_sdk_editable="false"
    if ${MONAI_PY_EXE} $TOP/monai/deploy/utils/importutil.py is_dist_editable monai-app-sdk; then
        is_sdk_editable="true"
    fi

    c_echo b "monai_package_path: " Z "${monai_package_path}"
    c_echo b "sdk_package_path  : " Z "${sdk_package_path}"
    c_echo b "is_sdk_editable   : " Z "${is_sdk_editable}"

    if [ "${is_sdk_editable}" == "false" ]; then
        c_echo W "Installing monai-app-sdk in edit mode..."
        if [ -n "${VIRTUAL_ENV}" ] || [ -n "${CONDA_PREFIX}" ]; then
            run_command ${MONAI_PY_EXE} -m pip install -e .
        else
            c_echo_err R "You must be in a virtual environment to install monai-app-sdk in edit mode."
        fi

        if ${MONAI_PY_EXE} $TOP/monai/deploy/utils/importutil.py is_dist_editable monai-app-sdk; then
            is_sdk_editable="true"
        fi

        sdk_package_path=$(${MONAI_PY_EXE} $TOP/monai/deploy/utils/importutil.py dist_module_path monai-app-sdk)
        c_echo b "sdk_package_path  : " Z "${sdk_package_path}"
        c_echo b "is_sdk_editable   : " Z "${is_sdk_editable}"
    fi

    if [ "${is_sdk_editable}" = "false" ]; then
        c_echo W "Installing monai-app-sdk in edit mode..."
    fi

    if [ "$is_sdk_editable" = "true" ] && [ -n "${monai_package_path}" ] && [ ! -L ${monai_package_path}/monai/deploy ]; then
        c_echo W "Creating a symbolic link... " b "'${monai_package_path}/monai/deploy' " Z "->" b " '${sdk_package_path}/monai/deploy'"
        run_command ln -sfn ${sdk_package_path}/monai/deploy ${monai_package_path}/monai/deploy
    fi

    # Refresh command-line tools
    hash -r
}

setup_desc() { c_echo 'Setup development environment
'
}
setup() {
    install_python_dev_deps_
}

#==================================================================================
# Section: Test
#==================================================================================

test_desc() { c_echo 'Execute test cases

Arguments:
  $1 - subcommand [all] (default: all)
  $2 - test_type [all|unit|integration|system|performance] (default: all)
  $3 - test_component [all] (default: all)
'
}
test() {
    local subcommand="${1:-all}"
    local test_type="${2:-all}"
    shift;

    if [ "$subcommand" = "all" ] || [ "$subcommand" = "python" ]; then
        test_python "$@"
    fi
}

test_python() {
    local test_type="${1:-all}"
    local test_component="${2:-all}"
    local result=0

    local testsuite=""
    local testsuite_performance="tests/performance"

    install_python_dev_deps_

    if [ "$test_type" = "all" ] || [ "$test_type" = "unit" ]; then
        local testsuite="tests/unit"
    fi
    if [ "$test_type" = "all" ] || [ "$test_type" = "performance" ]; then
        testsuite="${testsuite} ${testsuite_performance}"
    fi

    pushd $TOP > /dev/null
    run_command py.test --cache-clear -vv \
        --cov=monai \
        --junitxml="$TOP/junit-monai-app-sdk.xml" \
        --cov-config=$TOP/.coveragerc \
        --cov-report=xml:"$TOP/monai-app-sdk-coverage.xml" \
        --cov-report term \
        ${testsuite}
    result=$?
    popd > /dev/null

    return $result
}


#==================================================================================
# Section: Example
#==================================================================================


#==================================================================================
# Section: Documentation
#==================================================================================

#==================================================================================
# Section: Release
#==================================================================================


#==================================================================================

parse_args() {
    local OPTIND
    while getopts 'yh' option;
    do
        case "${option}" in
            y)
                ALWAYS_YES=true;
                ;;
            h)
                print_usage
                exit 1
                ;;
            *)
                ;;
        esac
    done
    shift $((OPTIND-1))

    CMD="$1"
    shift

    ARGS=("$@")
    # Check if the command has `--help` or `-h` and override the CMD
    local arg
    for arg in "${ARGS[@]}"; do
        if [ "$arg" = "--help" ] || [ "$arg" = "-h" ]; then
            ARGS=("$CMD")
            CMD="help"
            break
        fi
    done
}

print_usage() {
    set +x
    echo_err
    echo_err "USAGE: $0 [command] [arguments]..."
    echo_err ""
    c_echo_err W "Global Arguments"
    echo_err
    c_echo_err W "Command List"
    c_echo_err Y "    help  " w "----------------------------  Print detailed description for a given argument (command name)"
    echo_err "$(get_list_of_available_commands color "${RUN_SCRIPT_FILE}" | my_cat_prefix " ")"
    echo_err
}

print_cmd_help_messages() {
    local cmd="$1"
    if [ -n "${cmd}" ]; then
        if type ${cmd}_desc > /dev/null 2>&1; then
            ${cmd}_desc
            exit 0
        else
            c_echo_err R "Command '${cmd}' doesn't exist!"
            exit 1
        fi
    fi
    print_usage
    return 0
}

main() {
    local ret=0
    parse_args "$@"

    case "$CMD" in
        help)
            print_cmd_help_messages "${ARGS[@]}"
            exit 0
            ;;
        ''|main)
            print_usage
            ;;
        *)
            if type ${CMD} > /dev/null 2>&1; then
                "$CMD" "${ARGS[@]}"
            else
                print_usage
                exit 1
            fi
            ;;
    esac
    ret=$?
    if [ -n "${SCRIPT_DIR}" ]; then
        exit $ret
    fi
}

init_globals

if [ -n "${SCRIPT_DIR}" ]; then
    main "$@"
fi


# Description template

# Globals:
#   MONAI_OS
#   MONAI_TARGET
#   MONAI_USER (used if MONAI_OS is "linux")
#   MONAI_HOST (used if MONAI_OS is "linux")
# Arguments:
#   Command line to execute
# Returns:
#   Outputs print messages during the execution (stdout->stdout, stderr->stderr).

#   Note:
#     This command removes "\r" characters from stdout.

#   Exit code:
#     exit code returned from executing a given command
